# optimal.py
import random

# ==========================================
# ‚úÖ OPTIMAL: IDEMPOTENCY KEY
# ==========================================
# STRATEGY:
# 1. Client generates a unique ID (UUID) for the transaction.
# 2. Server stores check: "Have I seen this ID before?"
# 3. If yes, return previous result. Do NOT charge again.

class IdempotentBank:
    def __init__(self):
        self.balance = 100
        self.processed_tx = set()
        
    def charge(self, amount, idempotency_key):
        if idempotency_key in self.processed_tx:
            print(f"   ü§ö [Dedup] Key {idempotency_key} already processed. Ignored.")
            return True
        
        # Simulate Processing
        print(f"   üîÑ Processing Key {idempotency_key}...")
        self.processed_tx.add(idempotency_key)
        self.balance -= amount
        print(f"   ‚úÖ Charged ${amount}. Balance: {self.balance}")
        return True

if __name__ == "__main__":
    bank = IdempotentBank()
    key = "tx_123_abc" # Generated by client
    
    # 1st Attempt
    bank.charge(10, key)
    
    # 2nd Attempt (Retry caused by network timeout)
    bank.charge(10, key)
    
    print("\nüèÜ Insight: Idempotency is critical for Fintech (Stripe/PayPal).")
    print("   Never rely on network reliability. Rely on Unique Keys.")
